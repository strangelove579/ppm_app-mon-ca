#!/usr/bin/perl
# Written by Chris Gralike @ AMIS.
# Perl based check command to fetch and report the
# TPS (transactions per second) and IO wait times.
# Plugin uses iostat for opperation.
# Verion 0.9.7
#
# Changes post 0.9.7 >> 28-05-2010
# Line 298...303 Prevent devision by zerro else exit because no data was collected  - Bug reported by Epiq.
# Line 380       Correction of a type that prevented pref data of r/s w/s from being printed. - Bug reported by Epiq.
# Line 40        Added dm as possible device input used by the linux LVM. - Suggested by Epiq.
# Line 269       Extended the device if/pragmatch validation to match more devices - Added by Jean Ventura.
#Line 60         added to accept /fs0 as device type instead of sda,hda,etc....(Ramu Boga)
#Line 211 ..225 added the another option to the command line arguments ( Ramu Boga)
#Line 479,482,485 modified the output of the script ( Ramu Boga)

# Changes 9/6/2012 Mai Le
# Line 62 - 78 Add in checking for HBS and NRD which use /dev/mapper/vgfsXXX

# Changes 10/30/2012 Mai Le
# Line 388 change to 6 samples. Update output to say i/o utilization
# Add detection of processes to skip
# Add writing logs to logmon log file
# Add SID -- some systems have multiple SID
#
# Changes 08/12/2013 John Achee
# This is a new version, for clarity app servers. Removed Oracle SID code
#########################
use Switch;
use warnings;

my (
    $numArgs,
    $debug, # Print debugging information.
    $DevType,       # Used to match a certain devicetype from the resulting IOstat rows.
    $IOBIN, # Is used to store a path to the iostat binairy for execution.
    $Samples,       # Used to store the initial Samples returned by iostat.
    @SampleRows,    # Used to store the rows generated by the splitted samples.
    $firstseen, # Used to keep track of the found devices (IOstat might return a set of devices i.e sda, sdb, sdc etc.)
    $Items,    # Used in the foreach to store the row being parsed.
    @cols,     # Used to store the columns in a row after an split.
    $dev,      # Used to create a symbolic link to dynamicly create a var.
    $rqm,
    $val,
    $devtypes,
    $rws, $rws_warn, $rws_crit,
    $kbs, $kbs_warn, $kbs_crit,
    $awt, $awt_warn, $awt_crit,
    $svc, $svc_warn, $svc_crit,
    $devices, $itd, $v1, $v2, $v3,
    $v4,  $v5,       $v6,       $v7, $v8, $v9, $v10, $v11,
    $dbu, $dbu_warn, $dbu_crit, $dbstatus,
    $samples,    # Number of samples to average thresold for alarming
#    $SID,
    @ignore_processes # Specify the processes to ignore in calculation. (dba wants to ignore backup time)
                      # separate by commas
);

# Preparing to collect the dangerious user input.
# Here is a list of known device types. Please add any device you would like to monitor..
$avg_value       = 0;
$cpu_util        = 0;
$ignore          = 0;
$devtypes        = ";sda;hd;dm;/fs0;vgfs;VolGroup";
$numArgs         = $#ARGV + 1;
$critical_global = 0;
$warning_global  = 0;
$minor_global    = 0;
$logfile         = "/fs0/od/nimsoft/probes/system/logmon/logmon.log";
if ( $numArgs gt '0' ) {

    for ( $i = 0 ; $i < $numArgs ; $i++ ) {

        # Process our command line arguments and do some basic testing.
        # Could be make human save in the future.
        switch ( $ARGV[$i] ) {

            # Enable debugging.
            case '-debug' {
                $debug = 1;
            }
            #case '-sid' {
            #    $SID = $ARGV[ $i + 1 ];
            #    $i++;
            #}

            # Handle device type
            case '-d' {
                $val_device = $ARGV[ $i + 1 ];
                $DevType    = `df -Th | grep $val_device\$ | cut -c6-9`;

                # Check if it found the device
                if ( ( index( $devtypes, $val_device ) ) gt '-1' ) {
                    $i++;
                }
                else {

                    # probably HBS or NRD with volume groups
                    $val_device = substr( $val_device, 1, 3 );
                    $val_device = "vg" . $val_device;
                    $DevType    = `df -Th |grep $val_device | cut -d/ -f4`;
                    $val_device_to_test = substr( $val_device, 0, 1 );
                    if ( ( index( $devtypes, $val_device_to_test ) ) gt '-1' ) {
                        $i++;
                    }
                    else {
                        print "MAJOR: Invalid Disktype found. Typo?\n";
                        exit 1;
                    }
                }
            }
            case '-rqm' { $rqm = '1'; }

            # What is the warning treshold?
            case '-rqmw' {
                $val = $ARGV[ $i + 1 ];

                # Is the value nummeric?
                if ( $val =~ m/[0-9]*/ ) {
                    $rqm_warn = int $val;
                    $i++;
                }
                else {

                    # Possible type?
                    print "Non Numeric value used in rqmw, typo? \n";
                    exit 1;
                }
            }
            case '-rqmc' {
                $val = $ARGV[ $i + 1 ];

                # Is the value nummeric?
                if ( $val =~ m/[0-9]*/ ) {
                    $rqm_crit = int $val;
                    $i++;
                }
                else {

                    # Possible type?
                    print "Non Numeric value used in rqmc, typo? \n";
                    exit 1;
                }
            }

            # Do we need to check rws?
            case '-rws' { $rws = '1'; }
            case '-rwsw' {
                $val = $ARGV[ $i + 1 ];

                # Is the value nummeric?
                if ( $val =~ m/[0-9]*/ ) {
                    $rws_warn = int $val;
                    $i++;
                }
                else {

                    # Possible type?
                    print "Non Numeric value used in rwsw, typo? \n";
                    exit 1;
                }
            }
            case '-rwsc' {
                $val = $ARGV[ $i + 1 ];

                # Is the value nummeric?
                if ( $val =~ m/[0-9]*/ ) {
                    $rws_crit = int $val;
                    $i++;
                }
                else {

                    # Possible type?
                    print "Non Numeric value used in rwsc, typo? \n";
                    exit 1;
                }
            }

            # Do we need to check kbs?
            case '-kbs' { $kbs = '1'; }
            case '-kbsw' {
                $val = $ARGV[ $i + 1 ];

                # Is the value nummeric?
                if ( $val =~ m/[0-9]*/ ) {
                    $kbs_warn = int $val;
                    $i++;
                }
                else {

                    # Possible type?
                    print "Non Numeric value used in kbsw, typo? \n";
                    exit 1;
                }
            }
            case '-kbsc' {
                $val = $ARGV[ $i + 1 ];

                # Is the value nummeric?
                if ( $val =~ m/[0-9]*/ ) {
                    $kbs_crit = int $val;
                    $i++;
                }
                else {

                    # Possible type?
                    print "Non Numeric value used in kbsc, typo? \n";
                    exit 1;
                }
            }

            # Do we need to check awt?
            case '-awt' { $awt = '1'; }
            case '-awtw' {
                $val = $ARGV[ $i + 1 ];

                # Is the value nummeric?
                if ( $val =~ m/[0-9]*/ ) {
                    $awt_warn = int $val;
                    $i++;
                }
                else {

                    # Possible type?
                    print "Non Numeric value used in awtw, typo? \n";
                    exit 1;
                }
            }
            case '-awtc' {
                $val = $ARGV[ $i + 1 ];

                # Is the value nummeric?
                if ( $val =~ m/[0-9]*/ ) {
                    $awt_crit = int $val;
                    $i++;
                }
                else {

                    # Possible type?
                    print "Non Numeric value used in awtc, typo? \n";
                    exit 1;
                }
            }

            # Do we need to check svc?
            case '-svc' { $svc = '1'; }
            case '-svcw' {
                $val = $ARGV[ $i + 1 ];

                # Is the value nummeric?
                if ( $val =~ m/[0-9]*/ ) {
                    $svc_warn = int $val;
                    $i++;
                }
                else {

                    # Possible type?
                    print "Non Numeric value used in svcw, typo? \n";
                    exit 1;
                }
            }
            case '-svcc' {
                $val = $ARGV[ $i + 1 ];

                # Is the value nummeric?
                if ( $val =~ m/[0-9]*/ ) {
                    $svc_crit = int $val;
                    $i++;
                }
                else {

                    # Possible type?
                    print "Non Numeric value used in svcc, typo? \n";
                    exit 1;
                }
            }

            # Do we need to check dbu?
            case '-dbu' { $dbu = '1'; }
            case '-dbuw' {
                $val = $ARGV[ $i + 1 ];

                # Is the value nummeric?
                if ( $val =~ m/[0-9]*/ ) {
                    $dbu_warn = int $val;
                    $i++;
                }
                else {

                    # Possible type?
                    print "Non Numeric value used in dbuw, typo? \n";
                    exit 1;
                }
            }
            case '-dbuc' {
                $val = $ARGV[ $i + 1 ];

                # Is the value nummeric?
                if ( $val =~ m/[0-9]*/ ) {
                    $dbu_crit = int $val;
                    $i++;
                }
                else {

                    # Possible type?
                    print "Non Numeric value used in dbuc, typo? \n";
                    exit 1;
                }
            }
### Adding processes to skip ####
            case '-ignore' {
                $val = $ARGV[ $i + 1 ];

                # Split the process name using commas
                @ignore_processes = split( ",", $val );
                $i++;
            }
#########Code added by Ramu##############
            case '-s' {
                $val     = $ARGV[ $i + 1 ];
                $samples = $val;
                $i++;
            }

            case '-dbum' {
                $val = $ARGV[ $i + 1 ];

                # Is the value nummeric?
                if ( $val =~ m/[0-9]*/ ) {
                    $dbu_min = int $val;
                    $i++;
                }
                else {

                    # Possible type?
                    print "Non Numeric value used in dbuc, typo? \n";
                    exit 1;
                }
            }

#############################################################
# performance data. Might make the string human unreadable.. ow well, no loss there <img src="https://s-ssl.wordpress.com/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley">
#case '-p'    { $prf='1'; }
# Print full messages per device overview.
#case '-m'    { $fms='1'; }
# Most used help switches.
            case '--help' { USAGE(); }
            case '-h'     { USAGE(); }
        }
    }

    # Check if the basic requirements are met.
    if (   !($DevType)
#        || !($SID)
        || !($samples)
        || !( ( $rqm || $rws || $kbs || $awt || $svc || $dbu ) ) )
    {
        Update_LOG( "Minimal requirements not met. Can't run iostat job.", $logfile, "1" );
        print "Minimal requiremens, device and checktype are not met\n";
        USAGE();
    }
}
else {

    # No input was given. Show the Usage();
    USAGE();
}

# Locate the IOBin binairy needed to fetch the stats.
chomp( $IOBIN = `which iostat` );

if ( !( -f $IOBIN ) || !( -x $IOBIN ) ) {
    print "A working iostat command is needed for this script to work \n";
    print "Also make sure the sysstat service is running! /etc/init.d/sysstat \n";
    exit 1;
}

if ($DevType) {

    # IF IOStat is found, lets collect some data.
    chomp( $Samples = `$IOBIN -N -d -x -k 1 5 | grep $DevType` );
}
else {
    print "Please select a valid devicetype \n";
    exit 1;
}

# Break the samples up in lines so we can evaluate them.
# The first set of samples are avg. values counted from boot.
# We need to discard them and collect the remaining samples.
@SampleRows = split( /\n/, $Samples );

# Firstseen is used to track de device names and to skip the first itteration of iostat that contains
# avg stats counted from system boot time, stats we cant use here sadly <img src="https://s-ssl.wordpress.com/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley">
$firstseen = '';
$CT        = 0;
$Devices   = 0;

# Print Debugging information
if ($debug) {
    print "### Data collected ###\n";
    print "dev|rrqm|wrqm|r/s|w/s|rKB/s|wKB/s|rq-sz|qu-sz|await|svctm|util%|\n";
}

foreach $Items (@SampleRows) {

    # Break the latter up in usable columns.
    @cols = split( /\s+/, $Items );

    # We only want a certain device type. So lets match what we know.
    # Disks usualy have a prefix for example (scsi = sd) its set using
    # the DevType var.
    chomp($DevType);
    if (   $cols[0] =~ m/$DevType-[0-9]$/
        || $cols[0] =~ m/$DevType[a-z]$/
        || $cols[0] =~ m/$DevType[a-z][0-9]$/
        || $cols[0] =~ m/$DevType[0-9]$/
        || $cols[0] =~ m/$DevType/ )
    {
        $dev = $cols[0];
        if ( ( rindex $firstseen, $dev ) gt '-1' ) {

            #Declare new $$
            #my @$dev;
            # Store the collected data in the correct (dynamic) vars.
            $$dev[1] += $cols[1];   # rrqm/s   Read Requests Merged per Second.
            $$dev[2] += $cols[2];   # wrqm/s   Write Requests Merged per Second.
            $$dev[3] += $cols[3];    # r/s      Number of read requests issued per Second
            $$dev[4] += $cols[4];    # w/s      Number of write requests issued per Second
            $$dev[5] += $cols[5];    # rKB/s    Number of Kilobytes read per Second.
            $$dev[6] += $cols[6];    # wKB/s    Number of Kilobytes written per Second.
            $$dev[7] += $cols[7];    # Avgrq-sz Avarage size (in sectors) of the issued requests.
            $$dev[8] += $cols[8];  # Avgqu-sz Avarage Queue length of the requests issued.
            $$dev[9] += $cols[9];  # Await	  Avarage wait time in ms for IO requests to be served.
            $$dev[10] += $cols[10]; # svctm    Avarage service time in ms for IO requests that where issued.
            $$dev[11] += $cols[11]; # %util    Precentage of CPU time during IO requests (bandwidth util), saturation at 90~100%
            $CT++;    # Add a new itteration to the count
             # Print some debugging vars if requested. to show the data is collected.

            if ($debug) {
                print "$dev|$cols[1]|$cols[2]|$cols[3]|$cols[4]|$cols[5]|$cols[6]|$cols[7]|$cols[8]|$cols[9]|$cols[10]|$cols[11]|\n";
            }
        }
        else {
            $Devices++;
            $firstseen .= "$dev;";
        }
    }
}

# Prevent $itd (itterations / disk) from becomming zerro and exit when no devices are found.
# on line 299.
if ( $Devices > 0 ) {
    $itd = ( $CT / $Devices );
}
else {
    print "No performance data was captured. Please check if the device name is correct\n";
    exit 1;
}

# Print debugging information
if ($debug) {
    print "###Devices Counted###\n";
    print "Number of devices : $Devices\n";
    print "Number of itterations per device : $itd\n";
    print "Total Number of Itterations : $CT\n";
}

# Lets collect the device information from the firstseen var
# and start processing it for some perf check/data
# Lets also recycle some previously used vars for this.
@cols = split( /;/, $firstseen );
foreach $Items (@cols) {

    # Items now contains the devicenames needed to access the data again.
    # We now need to check them against some basic tresholds
    # Print a nice table with the calculated values when we are in debug.

    # Print debugging information
    if ($debug) {
        print "### Counted Values ###\n";
        print "$Items|$$Items[1]|$$Items[2]|$$Items[3]|$$Items[4]|$$Items[5]|$$Items[6]|$$Items[7]|$$Items[8]|$$Items[9]|$$Items[10]|$$Items[11]|\n";
    }

    #What do we want to check against a treshold?
    #First check the selection if any.
    if ( $rqm || $rws || $kbs || $awt || $svc || $dbu ) {

        #Set the counts to zerro
        $critical_state = '0';
        $warning_state  = '0';
        $ok_state       = '0';
        $minor_state    = '0';


        # Devide
        $round = "%.2f";
        $v1    = sprintf( $round, ( $$Items[1] / $itd ) );
        $v2    = sprintf( $round, ( $$Items[2] / $itd ) );
        $v3    = sprintf( $round, ( $$Items[3] / $itd ) );
        $v4    = sprintf( $round, ( $$Items[4] / $itd ) );
        $v5    = sprintf( $round, ( $$Items[5] / $itd ) );
        $v6    = sprintf( $round, ( $$Items[6] / $itd ) );
        $v7    = sprintf( $round, ( $$Items[7] / $itd ) );
        $v8    = sprintf( $round, ( $$Items[8] / $itd ) );
        $v9    = sprintf( $round, ( $$Items[9] / $itd ) );
        $v10   = sprintf( $round, ( $$Items[10] / $itd ) );
        $v11   = sprintf( $round, ( $$Items[11] / $itd ) );

##########Code Added by Ramu ##########
        $cpu_util = $v11;


        # Skip if there are ignore processes going

        if ($debug) { print "Processes to ignore: @ignore_processes\n"; }

        #PROCESS:
        foreach (@ignore_processes) {

            # see if it is running
            #if ( $_ eq "dbstats" ) {
            #    $dbstatus = `su - oracle -c \"/fs0/od/nimsoft/probes/super/dba_11_ora/bin/check_dbstat.sh $SID\" | tail -1`;
            #    chomp($dbstatus);
            #    if ( $dbstatus eq "TRUE" ) {
            #        Update_LOG( "DBstat job is running. Exiting", $logfile, "3" );
            #        system("cat /dev/null > /tmp/iostat_threshold");    # restart sampling
            #        $ignore = 1;
            #        exit 0;
            #    }
            #    else {
            #        Update_LOG( "Dbstat job is not running.", $logfile, "3" );
            #        next;
            #    }
            #}
            my $process_running = `ps -ef | grep $_ | grep -v \"Performance\" |wc -l`;
            if ( $process_running > 2 ) {
                if ($debug) { print "$_ is running\n"; }
                Update_LOG( "$_ is running. Exiting", $logfile, "3" );
                system("cat /dev/null > /tmp/.iostat_threshold");    # restart sampling data
                       #set all threshold to be ignore
                $ignore = 1;
                exit 0;

       #   last PROCESS; # something is running, no need to chck another process
            }
        }

       # avg_ioutilization
       $total = 0;
       open( FILE, '>>/tmp/.iostat_threshold' )
              || print "Unable to open the file /tmp/.iostat_threshold";
       print FILE "$v11" . "\n";
       
       if ( `wc -l </tmp/.iostat_threshold` == $samples ) { 
          $iostat_total = `cat /tmp/.iostat_threshold`;
          @iostat_total = split( "\n", $iostat_total );
          foreach $var (@iostat_total) {
             $total = $total + $var;
          }
          $avg_value = $total / $samples;
          truncate( FILE, 0 ); 
        }
        close(FILE);
        # Skip if there are ignore processes going

        # Requests Merged per second.
        if ($rqm) {

            # Critical
            if ( ( $v1 >= $rqm_crit ) || ( $v2 >= $rqm_crit ) ) {
                $critical_state += '1';
                # Warning?
            }
            elsif ( ( $v1 >= $rqm_warn ) || ( $v2 >= $rqm_warn ) ) {
                $warning_state += '1';
                # Ok
            }
            else {
                $ok_state += '1';
            }
            # Add the counters to the performance vars
            $perf .= "$Items-rrqm/s=$v1; $Items-wrqm/s=$v2;";
        }

        # Reads / Writes per second.
        if ($rws) {
            if ( ( $v3 >= $rws_crit ) || ( $v4 >= $rws_crit ) ) {
                $critical_state += '1';
                # Warning?
            }
            elsif ( ( $v3 >= $rws_warn ) || ( $v4 >= $rws_warn ) ) {
                $warning_state += '1';
                # Ok
            }
            else {
                $ok_state += '1';
            }

            # Add the counters to the performance var.
            $perf .= "$Items-r/s=$v3; $Items-w/s=$v4; ";
        }

        # KB Read/Writes per second.
        if ($kbs) {
            if ( ( $v5 >= $kbs_crit ) || ( $v6 >= $kbs_crit ) ) {
                $critical_state += '1';

                # Warning?
            }
            elsif ( ( $v5 >= $kbs_warn ) || ( $v6 >= $kbs_warn ) ) {
                $warning_state += '1';

                # Ok
            }
            else {
                $ok_state += '1';
            }
            $perf .= "$Items-rKB/s=$v5; $Items-wKB/s=$v6; ";
        }

        # Avarage wait time
        if ($awt) {
            if ( ( $v9 >= $awt_crit ) ) {
                $critical_state += '1';

                # Warning?
            }
            elsif ( ( $v9 >= $awt_warn ) ) {
                $warning_state += '1';

                # Ok
            }
            else {
                $ok_state += '1';
            }
            $perf .= "$Items-await=$v9; ";
        }

        # Avarage service time issuing time
        if ($svc) {
            if ( $v10 >= $svc_crit ) {
                $critical_state += '1';

                # Warning?
            }
            elsif ( $v10 >= $svc_warn ) {
                $warning_state += '1';

                # Ok
            }
            else {
                $ok_state += '1';
            }
            $perf .= "$Items-svctm=$v10; ";
        }

        # Disk bandwidth Utilization
        if ($dbu) {
            if ( defined($avg_value) ) {
                if ( $avg_value >= $dbu_crit ) {
                    $critical_state += '1';

                    # Warning?
                }
                elsif ( $avg_value >= $dbu_warn ) {
                    $warning_state += '1';

                    # Ok
                }
                elsif ( defined $dbu_min && $avg_value >= $dbu_min ) {
                    $minor_state += '1';
                }
                else {
                    $ok_state += '1';
                }
                $perf .= "$Items-util=$v11%; ";
            }
            unless ($critical_state || $warning_state || $minor_state) {
                print "current_cpu_utilization:$cpu_util" . "\n" ;#if $debug;
            } 
        }
    }
    else {
        print "At least select a value to measure..\n";
        exit 1;
    }

    # Print Debugging information about the validated values.
    if ($debug) {
        print "### validated Devisions ###\n";
        print "$Items|$v1|$v2|$v3|$v4|$v5|$v6|$v7|$v8|$v9|$v10|$v11|\n";
    }

# Create a messages var.
#$mgs.="$Items=OK:$ok_state,W:$warning_state,C:$critical_state,M:$minor_state; ";

    # Track the global state (1 crit 1 warn)
    if ( ( $critical_state gt '0' ) || ( $critical_global gt '0' ) ) {
        $critical_global += '1';
    }
    if ( ( $warning_state gt '0' ) || ( $warning_global gt '0' ) ) {
        $warning_global += '1';
    }
    if ( ( $minor_state gt '0' ) || ( $minor_global gt '0' ) ) {
        $minor_global += '1';
    }

}

# Compose a nice nagios output.

if ( $critical_global >= '1' ) {
    $avg_value = sprintf( "%.2f", $avg_value );
    print "CRITICAL: Avg $val_device i/o utilization is  $avg_value %";
    $exit = 2;
}
elsif ( $warning_global >= '1' ) {
    $avg_value = sprintf( "%.2f", $avg_value );
    print "MAJOR:Avg $val_device i/o utilization is $avg_value%";
    $exit = 1;
}
elsif ( $minor_global >= '1' ) {
    $avg_value = sprintf( "%.2f", $avg_value );
    print "MINOR:Avg $val_device i/o utilization is $avg_value %";
    $exit = 3;
}
else {

    #	print "OK:$avg_value";
    $exit = 0;
}

# Print the remainder, the most important data was processed.
#print $mgs;
#if($prf){ print "|$perf"; } print "\n";
#exit $exit;

###Subroutines
sub Update_LOG {
    my $LOGMESSAGE = shift;
    my $LOGFILE    = shift;
    my $LOGTYPE    = shift;
    my ( $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst ) = localtime(time);
    my $timestamp = sprintf("%4.4d-%2.2d-%2.2d %2.2d:%2.2d:%2.2d",$year + 1900,$mon + 1, $mday, $hour, $min, $sec);
    
    my $TYPE;
    $TYPE = "[[ ERROR ]]"   if $LOGTYPE == 1;
    $TYPE = "[[ WARNING ]]" if $LOGTYPE == 2;
    $TYPE = "[[ DEBUG ]]"   if $LOGTYPE == 3;
    open( $LOG, ">>$LOGFILE" );
    print $LOG "$timestamp $TYPE $LOGMESSAGE\n";
    close($LOG);
}

sub USAGE {
    print "
                Usage : $0 -d [Dev] [options] -ignore [processes] -s [number of samples]

		-p Print performance data about the measured samples.

		-d {grep string used on IOstat}
		examples;
         sd     #All scsi devices.
         hd     #All Cdrom devices.
		 sda	#Only device sda
		-ignore list of proceses separated by commas
		-s [number of samples to average]
                [Available Measurement Options]
                -rqm -rqmw val -rqmc val        # read/write merged             [#]
                -rws -rwsw val -rwsc val        # read/write per second.        [s]
                -kbs -kbsw val -kbsc val        # KBs read/written per second.  [s]
                -awt -awtw val -awtc val        # Avarage IO wait time.         [ms]
                -svc -svcw val -svcc val        # Avarage service IO wait time. [s]
                -dbu -dbuw val -dbuc val        # Disk utilization              [%]\n";
    exit 1;
}

